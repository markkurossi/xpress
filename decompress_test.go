//
// decompress_test.go
//
// Copyright (c) 2018 Markku Rossi
//
// All rights reserved.
//

package xpress

import (
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"testing"
)

const verbose bool = false

var lz77Inputs = [][]byte{
	[]byte{
		0x3f, 0x00, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64,
		0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
		0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74,
		0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
	},
	[]byte{
		0xff, 0xff, 0xff, 0x1f, 0x61, 0x62, 0x63, 0x17,
		0x00, 0x0f, 0xff, 0x26, 0x01,
	},
}

func TestLZ77(t *testing.T) {
	for _, data := range lz77Inputs {
		bytes, err := DecompressLZ77(data)
		if err != nil {
			t.Errorf("LZ77 failed: %s\n", err)
			continue
		}
		fmt.Printf("LZ7: %d => %d\n", len(data), len(bytes))
		if verbose {
			fmt.Printf("=>\n%s", hex.Dump(bytes))
		}
	}
}

var lz77HuffmanInputs = [][]byte{
	[]byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x45, 0x44, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd8, 0x52, 0x3e, 0xd7, 0x94, 0x11, 0x5b, 0xe9,
		0x19, 0x5f, 0xf9, 0xd6, 0x7c, 0xdf, 0x8d, 0x04,
		0x00, 0x00, 0x00, 0x00,
	},
}

func TestLZ77Huffman(t *testing.T) {
	for _, data := range lz77HuffmanInputs {
		bytes, err := DecompressLZ77Huffman(data, nil)
		if err != nil {
			t.Errorf("LZ77+Huffman failed: %s\n", err)
			continue
		}
		fmt.Printf("=> %d\n", len(bytes))
		if verbose {
			fmt.Printf("=>\n%s", hex.Dump(bytes))
		}
	}
}

var lznt1Inputs = [][]byte{
	[]byte{
		0x38, 0xb0, 0x88, 0x46, 0x23, 0x20, 0x00, 0x20,
		0x47, 0x20, 0x41, 0x00, 0x10, 0xa2, 0x47, 0x01,
		0xa0, 0x45, 0x20, 0x44, 0x00, 0x08, 0x45, 0x01,
		0x50, 0x79, 0x00, 0xc0, 0x45, 0x20, 0x05, 0x24,
		0x13, 0x88, 0x05, 0xb4, 0x02, 0x4a, 0x44, 0xef,
		0x03, 0x58, 0x02, 0x8c, 0x09, 0x16, 0x01, 0x48,
		0x45, 0x00, 0xbe, 0x00, 0x9e, 0x00, 0x04, 0x01,
		0x18, 0x90, 0x00,
	},
}

func testLZNT1(t *testing.T) {
	for _, data := range lznt1Inputs {
		bytes, err := DecompressLZNT1(data)
		if err != nil {
			t.Errorf("LZNT1 failed: %s\n", err)
			continue
		}
		fmt.Printf("=> %d\n", len(bytes))
		if verbose {
			fmt.Printf("=>\n%s", hex.Dump(bytes))
		}
	}
}

var xp1 = `ggQRA5eQCAAAkAmQiQAAAAAJAAAFBgAJAACXZ3hoh5gJmXaWcIiZCHmAeIcHaAeYAJCQAFB3RodXmFVWllZVmWkAAAAAAAAAAAAJkAAJAAAAAAAAAJAJAACAAJAAAJCQAJAAkAAACAAAAAAAAAkAAAAACQCQAAAAkAAJkAAAAAAAAAAACZkAAAAAAACQAAAAAAAAAJgAAAAAAAAAlpCAAAAAAJCHCIAAAIAAAJaHkAmYAACAhomQAAAAAIB3B5mIAAAAAIeQCQAAAACQl5kACQAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrkWjhrh6JDM4XIfAvMqTve3Nv3HM3n4c7O52T4uPzd1T7vboF35f/zrPM7fLH4lc89o/+iQ+anKKZCsrc07aazQJBM5m2h59UMK1mi1QtNeGVWc2DNRYxNvlNXEenfEdNd+CmQEKo0tENAebUgZzKnKRJw+wOoKzSMXNH5D0HOmhCawLJnTLuPb3zf1HdS7VlLFNQ4IF81ZmaVaFoOjq9JDal7eL4k2oz51PaLKhjz6wFGRbcX14Z7ix7055yuA10tMx1aj9O8cdSqWWVCPc5BscRQQ6z47ghQqVp2cHCDWqbnKkkKBddkMhk5C+pIilFGuZU3TBPcOARHSk8ARN0AWZzXQi7TdvnqQCL1rog/o5Vk/ghXCkF9voJqr7hAjP0Qexy0MrDDy22o7vUDWsZfwktucxz9IjTIsF7xg7NanVPJuXcIamVHWUqQHHNZ8abudwBvRcDRkmzFptUL9anS3ywFGUFy7og/d9QbRsDOZEDCAssVGYbFkkfZMIuiwq06msmsBKJPcUiUlHCp6BrvqTJMiUVKVTjKhSE1M+TCKUuOWZYWHFjOYzGgOoW4NqoVxEC9xz0WxOfyEn7iGlw8DvSLFVf3ubmJ8Z2utoYO/o/Cmv+LX30+b8E9aHHXJVwDohBYheU16wXhYmhUz3A3TKsaqMrezEiSa+f7I37Bfrgf2lf43VCl0/4/ZgAACAAAA==`

var xp2 = `bgBuAAAAAAAAAAAJAAAAAAAAAAADAAAAWgEAAAAEEAQAP68a6aMMxEGrN6vSD7XEj3ajVjKHR15OtVAwg5iDvvjvu788Uz5QUyBDOlxVc2Vyc1xBZG1pbmlzdHJhdG9yXERvY3VtZW50cyZndDsgPC9TPg==`

var xp3 = `fQIlAoeHCAAAAAiAeIAAAAAIAAAIBgAAAAAAZnh3B4gAAHaFcHB3AGdwaHcHZwYHAICAAGB2V3dnB1ZWh2ZlAGgAAAAAAAAAAAAIgAAIAAAAAAAAAIAIAABwAIAAAICAAIAAgAAABwAAAAAAAAgAAAAACACAAAAAgAAIgAAAAAAAAAAACIgAAAAAAAAAAAAAAAAAAAcAAAAAAAAAhoiAAAAAAACIhnAAAHAAAIeAgAAHAAAAdgCAAAAAAABoBoiGAAAAgHAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADdhXihy+0KhZAaOdszUWsh6HDv9N3mc5XnVnc23RVb2hxcOnEmN0hvz58/Z6tvk6/alNopptLnGpJWmVY0QAD00OFQkiqXRf2k83loZG8EImAaEYHGcqGqRaqzBs4Fi0lJJEI1iGkb4mGoiBM0YmwAbcmrqdQAzzEtPAMUtpY+yfoRog6ySgMYx0YBxCmfGfMs6YCVK4i5EJBMSWIl4kHSHdJjT95lOnHrUtak9wOIS036G3QCSMa4BPmaAPhLHCMwo/TCU/SfHyfqSGq9eQpVUwRvTChBQUo7HmDO/Y7AX//HpkcMEQMtisRjcIYh2CXh1pG3OtzSml8is1XAIDLVovm/RiQNF4EgdlxSt2I36dPExqNoBJnmPt4Y80B+KYoH2gBgAAA=`

var xp4 = `9QTXApeYCQCQAAmQCQAAAAAJAAAIBgAAAAAAZWZmCJd4AIaVcHeXAHmQeIcHVweXAJCQAFB3V3hZiGZWB2ZlCHAJAAAAAAAAAAAAkAAAAAAAAAAAAJAAAACAAJAAAJAAAJAAkAAACAAAAAAAAAkAAAAAAACQAAAAkAAAkAAAAAAAAAAACZkAAAAJAAAAAAAAAAAAAHgAAAAAAAAAlwB4AAAAAABnB5cACQkAkHYIlgAJkAmQhpcHiZAJAGCGiACQAJgAcJcJgAAAmQiABwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADqjdnMPD3R2N65ZV7Ps2bp6kY6+G5+Q/9OYlO/yV/w0Xfsv67Pr/Hipa1TU4k25jTQ1iRBtAIG4c/xQtCLTZYLzqgzU6JBDOuY5I0ziw95k6fUydwwe2VFkbNOgCMbRq7JCCXBmcMijIACHaCcgsS6WpiYrrLaNLJZvmWWJdds63Ed3LfqOE8u4pjwOiKvpzRphe2Ss65YIc1bBDuAshJmlaMa59qzdIpU1al2d42ACFlTohsw99FOuPRrjncb7JRdP64xBtz6yoDekakDyqZpZi1wkXt3JO3piPtPiRThd/sp2pohOI50HwObsB21su9QISwJ941OxphZBZGxItqhLya8MmP5rgObm6/72sR7/7xdno2S50PTuuOvgb70rYj+p/gU3Fi4Pwr3Br/3zgM4skZeNg3vbY92+dcVTs96f7fUvh7AYQ8FjiJBSTo8ARH5//PuDWgXPt2NXv8bsQkCHQUqqYCcKGdckncqtAqdbhbZ8Fg6jq+6FZrhfwWTEFRAAcFIVo7Qa8doUzX7LkWhKUAFIgpFIwzlGuXuGRzTl4kJJoMFMpgv0yTe5RHyZnJMZdgHQTTY6lkxszzOOJRRzRBMVcQFXuyOLr8gzimIeVTpD9QAoAAA`

func TestDecompress(t *testing.T) {
	data, err := base64.StdEncoding.DecodeString(xp1)
	if err != nil {
		t.Fatalf("Failed to decode test data: %s\n", err)
	}
	if false {
		fmt.Printf("Input data:\n%s", hex.Dump(data))
	}
	if len(data) < 4 {
		t.Fatalf("Too short input\n")
	}
	infLen := (int(data[1]) << 8) | int(data[0])
	defLen := (int(data[3]) << 8) | int(data[2])

	var bytes []byte

	if infLen == defLen {
		bytes = data[4:]
	} else {
		bytes, err = DecompressLZ77Huffman(data[4:], make([]byte, 0, infLen))
		if err != nil {
			t.Fatalf("Decompress failed: %s\n", err)
		}
	}
	fmt.Printf("Decompressed data:\n%s", hex.Dump(bytes))
}
